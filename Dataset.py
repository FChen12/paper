import abc, FileUtil, re
from pathlib import Path

ROOT = Path(__file__).parent
DATASETS = ROOT / "datasets"
LABELED_FOLDER = DATASETS / "labeled"

class Dataset(abc.ABC):
    """
    Subclasses represent the evaluation datasets
    """
    def __init__(self):
        self._num_reqs = FileUtil.count_files(self.req_folder())
        self._num_code = FileUtil.count_files(self.code_folder())
        self._solution_matrix = None
        
    def num_reqs(self):
        return self._num_reqs
    
    def num_code(self):
        return self._num_code
    
    def all_original_code_file_names(self, with_extension=False):
        filenames_with_ext = [name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_code_filenames_file())]
        if with_extension:
            return filenames_with_ext
        else:
            return [FileUtil.get_filename_without_extension__from_path(filename) for filename in filenames_with_ext]
    
    def all_original_req_file_names(self, with_extension=False):
        filenames_with_ext = [name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_req_filenames_file())]
        if with_extension:
            return filenames_with_ext
        else:
            return [FileUtil.get_filename_without_extension__from_path(filename) for filename in filenames_with_ext]
        
    def encoding(self):
        return "utf-8-sig"
    @abc.abstractmethod
    def num_original_links(self):
        """
        original number all possible req/code links
        """
        pass
    
    @abc.abstractmethod
    def _all_code_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def _all_req_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def name(self):
        pass
    
    @abc.abstractmethod
    def folder(self):
        pass
    
    @abc.abstractmethod
    def code_folder(self):
        pass
    
    @abc.abstractmethod
    def req_folder(self):
        pass
    
    @abc.abstractmethod
    def method_callgraph(self):
        """
        returns the precalculated method call graph dictionary
        """
        pass
    
    @abc.abstractmethod
    def method_callgraph_path(self):
        pass
    @abc.abstractmethod
    def class_callgraph_path(self):
        pass
    @abc.abstractmethod
    def keys_with_extension(self):
        """
        True if the file names in the solution matrix are with file extensions
        """
        pass
    
    def solution_matrix(self, req_ext=None, code_ext=None):
        if self._solution_matrix is None:
            self._read_solution_matrix(req_ext, code_ext)
        return self._solution_matrix
    
    @abc.abstractmethod
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        pass
    
    @abc.abstractmethod
    def raw_call_graph_path(self):
        """
        Returns the path to the raw call graph file (generated by an external call graph parser )
        """
        pass
    @abc.abstractmethod
    def packages(self):
        """
        Lists the packages of the dataset.
        (needed for call graph generation to differentiate external classes)
        """
        pass
    @abc.abstractmethod
    def class_callgraph(self):
        pass

class Etour(Dataset):
    ETOUR_FOLDER = DATASETS / "eTour"
    ETOUR_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "traceabilityMatrixCleaned.txt"
    ETOUR_REQ_DIR = ETOUR_FOLDER / "req"
    ETOUR_CODE_DIR = ETOUR_FOLDER / "code"
    ETOUR_RAW_CALLGRAPH = ETOUR_FOLDER / "etour_raw_callgraph.txt"
    ETOUR_CLASS_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_class_callgraph.json"
    ETOUR_METHOD_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_method_callgraph.json"
    ETOUR_ALL_CODE_FILENAMES_FILE = ETOUR_FOLDER / "all_code_filenames.txt"
    ETOUR_ALL_REQ_FILENAMES_FILE = ETOUR_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "etour"
    
    def folder(self):
        return self.ETOUR_FOLDER
    
    def code_folder(self):
        return self.ETOUR_CODE_DIR
    
    def req_folder(self):
        return self.ETOUR_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.ETOUR_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ETOUR_ALL_REQ_FILENAMES_FILE
    
    def num_original_links(self):
        return 6728
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.ETOUR_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ETOUR_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.ETOUR_CLASS_CALLGRAPH_PATH
    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_txt_format_solution_matrix(self.ETOUR_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.ETOUR_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.ETOUR_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["beans", "com.trapan", "unisa.gps"]
    
class Etour308(Etour):
    ETOUR_FOLDER = DATASETS / "eTour308"
    ETOUR_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "AnswerSet.txt"
    ETOUR_ITAL_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "AnswerSet_Italian.txt"
    ETOUR_REQ_DIR = ETOUR_FOLDER / "req"
    ETOUR_CODE_DIR = ETOUR_FOLDER / "code"
    #ETOUR_RAW_CALLGRAPH = ETOUR_FOLDER / "etour_raw_callgraph.txt"
    #ETOUR_CLASS_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_class_callgraph.json"
    #ETOUR_METHOD_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_method_callgraph.json"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Use case name(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Description(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Participating Actor(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Entry (Operator |Tourist )?conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Exit conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("^Quality Requirements(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flow of events(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    
    def __init__(self, italian=False):
        super(Etour308, self).__init__()
        if italian:
            self.ETOUR_SOLUTION_MATRIX_PATH = self.ETOUR_ITAL_SOLUTION_MATRIX_PATH
            def with_key_extension():
                return True
            self.keys_with_extension = with_key_extension
            
    def name(self):
        return "etour308"
    
class Itrust(Dataset):
    
    ITRUST_FOLDER = DATASETS / "iTrust"
    ITRUST_SOLUTION_MATRIX_PATH = ITRUST_FOLDER / "answer_req_javacode.xml"
    ITRUST_REQ_DIR = ITRUST_FOLDER / "req"
    ITRUST_CODE_DIR = ITRUST_FOLDER / "code"
    ITRUST_RAW_CALLGRAPH = ITRUST_FOLDER / "itrust_raw_callgraph.txt"
    ITRUST_CLASS_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_class_callgraph.json"
    ITRUST_METHOD_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_method_callgraph.json"
    ITRUST_ALL_CODE_FILENAMES_FILE = ITRUST_FOLDER / "all_code_filenames.txt"
    ITRUST_ALL_REQ_FILENAMES_FILE = ITRUST_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "itrust"
    
    def num_original_links(self):
        return 29606
    
    def folder(self):
        return self.ITRUST_FOLDER
    
    def code_folder(self):
        return self.ITRUST_CODE_DIR
    
    def req_folder(self):
        return self.ITRUST_REQ_DIR
    def _all_code_filenames_file(self):
        return self.ITRUST_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ITRUST_ALL_REQ_FILENAMES_FILE
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.ITRUST_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ITRUST_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.ITRUST_CLASS_CALLGRAPH_PATH
    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_xml_format_solution_matrix(self.ITRUST_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.ITRUST_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.ITRUST_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["edu.ncsu.csc.itrust"]

class Libest(Dataset):
    
    LIBEST_FOLDER = DATASETS / "LibEST"
    LIBEST_SOLUTION_MATRIX_PATH = LIBEST_FOLDER / "req_to_code_ground.txt"
    LIBEST_REQ_DIR = LIBEST_FOLDER / "req"
    LIBEST_CODE_DIR = LIBEST_FOLDER / "code"
    LIBEST_RAW_CALLGRAPH = LIBEST_FOLDER / "libest_raw_callgraph.txt"
    LIBEST_CLASS_CALLGRAPH_PATH = LIBEST_FOLDER / ""
    LIBEST_METHOD_CALLGRAPH_PATH = LIBEST_FOLDER / "libest_method_callgraph.json"
    FAKE_C_LIB_HEADER = LIBEST_FOLDER / "fake_libc_include" # Needed to run the pycparser for libest code files
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^requirement [0-9]+(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_ACTOR_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_USER_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    
    LIBEST_ALL_CODE_FILENAMES_FILE = LIBEST_FOLDER / "all_code_filenames.txt"
    LIBEST_ALL_REQ_FILENAMES_FILE = LIBEST_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "libest"
    
    def num_original_links(self):
        return 728
    
    def folder(self):
        return self.LIBEST_FOLDER
    
    def code_folder(self):
        return self.LIBEST_CODE_DIR
    
    def req_folder(self):
        return self.LIBEST_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.LIBEST_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.LIBEST_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.LIBEST_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.LIBEST_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.LIBEST_CLASS_CALLGRAPH_PATH
    def keys_with_extension(self):
        return True
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_txt_format_solution_matrix(self.LIBEST_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.LIBEST_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.LIBEST_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return [] # Not implemented
class Smos(Dataset):
    
    SMOS_FOLDER = DATASETS / "smos"
    SMOS_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "answer_req_code.xml"
    SMOS_REQ_DIR = SMOS_FOLDER / "req"
    SMOS_CODE_DIR = SMOS_FOLDER / "code"
    SMOS_RAW_CALLGRAPH = SMOS_FOLDER / "smos_raw_callgraph.txt"
    SMOS_CLASS_CALLGRAPH_PATH = SMOS_FOLDER / "smos_class_callgraph.json"
    SMOS_METHOD_CALLGRAPH_PATH = SMOS_FOLDER / "smos_method_callgraph.json"
    SMOS_ALL_CODE_FILENAMES_FILE = SMOS_FOLDER / "all_code_filenames.txt"
    SMOS_ALL_REQ_FILENAMES_FILE = SMOS_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Descrizione(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Precondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Postcondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)# should never match -> smos doesn't have this element
    UC_USER_TEMPLATE_REGEX = re.compile("^Utente(:)?", re.RegexFlag.IGNORECASE)
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^Sistema(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Sequenza degli eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def name(self):
        return "smos"
    
    def num_original_links(self):
        return 6700
    
    def folder(self):
        return self.SMOS_FOLDER
    
    def code_folder(self):
        return self.SMOS_CODE_DIR
    
    def req_folder(self):
        return self.SMOS_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.SMOS_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.SMOS_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.SMOS_METHOD_CALLGRAPH_PATH)
    def method_callgraph_path(self):
        return self.SMOS_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.SMOS_CLASS_CALLGRAPH_PATH
    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_xml_format_solution_matrix(self.SMOS_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.SMOS_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.SMOS_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["smos"]
    
class SmosTrans(Smos):
    SMOS_FOLDER = DATASETS / "smosTrans"
    SMOS_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "UC2CC.csv"
    SMOS_REQ_DIR = SMOS_FOLDER / "req"
    SMOS_CODE_DIR = SMOS_FOLDER / "code"
    SMOS_RAW_CALLGRAPH = SMOS_FOLDER / "smosTrans_raw_callgraph.txt"
    SMOS_CLASS_CALLGRAPH_PATH = SMOS_FOLDER / "smosTrans_class_callgraph.json"
    SMOS_METHOD_CALLGRAPH_PATH = SMOS_FOLDER / "smosTrans_method_callgraph.json"
    SMOS_ALL_CODE_FILENAMES_FILE = SMOS_FOLDER / "all_code_filenames.txt"
    SMOS_ALL_REQ_FILENAMES_FILE = SMOS_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "smosTrans"
    
    def keys_with_extension(self):
        return True
    def encoding(self):
        return "ISO-8859-1"
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_txt_format_solution_matrix(self.SMOS_SOLUTION_MATRIX_PATH, req_ext, code_ext, delim=",")
    
    
class EANCI(Dataset):
    
    EANCI_FOLDER = DATASETS / "eANCI"
    EANCI_SOLUTION_MATRIX_PATH = EANCI_FOLDER / "solution_links.txt"
    EANCI_REQ_DIR = EANCI_FOLDER / "req"
    EANCI_CODE_DIR = EANCI_FOLDER / "code"
    EANCI_RAW_CALLGRAPH = EANCI_FOLDER / "eanci_raw_callgraph.txt"
    EANCI_CLASS_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_class_callgraph.json"
    EANCI_METHOD_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_method_callgraph.json"
    EANCI_ALL_CODE_FILENAMES_FILE = EANCI_FOLDER / "all_code_filenames.txt"
    EANCI_ALL_REQ_FILENAMES_FILE = EANCI_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome caso d'uso(:)?", flags=re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # should never match -> eAnci doesn't have this element
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori partecipanti(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Condizione di entrata(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Condizioni di uscita(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("Requisiti di qualita(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)# should never match -> eAnci doesn't have this element
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)# should never match -> eAnci doesn't have this element
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flusso di eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def name(self):
        return "eanci"
    
    def num_original_links(self):
        return 7645
    
    def folder(self):
        return self.EANCI_FOLDER
    
    def code_folder(self):
        return self.EANCI_CODE_DIR
    
    def req_folder(self):
        return self.EANCI_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.EANCI_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.EANCI_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.EANCI_METHOD_CALLGRAPH_PATH)
    def method_callgraph_path(self):
        return self.EANCI_METHOD_CALLGRAPH_PATH
    
    def class_callgraph_path(self):
        return self.EANCI_CLASS_CALLGRAPH_PATH
    
    def keys_with_extension(self):
        return True
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = FileUtil.read_txt_format_solution_matrix(self.EANCI_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.EANCI_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.EANCI_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["DB", "Servlet", "Bean"]
        
    def encoding(self):
        return "ISO-8859-1"
    
class Dronology(Dataset):
    
    DRONOLOGY_FOLDER = DATASETS / "dronology"
    DRONOLOGY_JSON_FILE =  DRONOLOGY_FOLDER / "dronologydataset01.json" #original dataset file containing trace links and requirements/design definitions
    DRONOLOGY_SOLUTION_MATRIX_PATH = DRONOLOGY_FOLDER / "dronology_trace_matrix.txt" #Extracted solution trace links from the json file
    DRONOLOGY_REQ_DIR = DRONOLOGY_FOLDER / "req"
    DRONOLOGY_CODE_DIR = DRONOLOGY_FOLDER / "code"
    DRONOLOGY_RAW_CALLGRAPH = DRONOLOGY_FOLDER / "dronology_raw_callgraph.txt"
    DRONOLOGY_METHOD_CALLGRAPH_PATH = DRONOLOGY_FOLDER / "dronology_method_callgraph.json"
    DRONOLOGY_CLASS_CALLGRAPH_PATH = DRONOLOGY_FOLDER / "dronology_class_callgraph.json"
    
    def name(self):
        return "dronology"
    
    def num_original_links(self):
        return 4257
    
    def folder(self):
        return self.DRONOLOGY_FOLDER
    
    def code_folder(self):
        return self.DRONOLOGY_CODE_DIR
    
    def req_folder(self):
        return self.DRONOLOGY_REQ_DIR
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.DRONOLOGY_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.DRONOLOGY_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.DRONOLOGY_CLASS_CALLGRAPH_PATH
    
    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix =  FileUtil.read_txt_format_solution_matrix(self.DRONOLOGY_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.DRONOLOGY_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.DRONOLOGY_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return [] # Not implemented
class DronologyDD(Dronology):
    """
    Using design definitions as requirements
    """
    
    DRONOLOGY_DD_SOLUTION_MATRIX_PATH = Dronology.DRONOLOGY_FOLDER / "dronology_dd_trace_matrix.txt"
    DRONOLOGY_DD_REQ_DIR = Dronology.DRONOLOGY_FOLDER / "dd"

    def name(self):
        return "dronology_dd"
    
    def req_folder(self):
        return self.DRONOLOGY_DD_REQ_DIR
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix =  FileUtil.read_txt_format_solution_matrix(self.DRONOLOGY_DD_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
